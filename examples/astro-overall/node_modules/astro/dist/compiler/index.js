var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = {exports: {}}).exports, mod), mod.exports;
};
var __reExport = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module) => {
  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? {get: () => module.default, enumerable: true} : {value: module, enumerable: true})), module);
};

// ../../node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "../../node_modules/tslib/tslib.js"(exports, module) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __spreadArray;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", {value: true});
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      __extends = function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      __rest = function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      __decorate = function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = {label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: []}, f, y, t, g;
        return g = {next: verb(0), "throw": verb(1), "return": verb(2)}, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return {value: op[1], done: false};
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return {value: op[0] ? op[1] : void 0, done: true};
        }
      };
      __exportStar = function(m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding(o, m, p);
      };
      __createBinding = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, {enumerable: true, get: function() {
          return m[k];
        }});
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __values = function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return {value: o && o[i++], done: !o};
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error2) {
          e = {error: error2};
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read(arguments[i]));
        return ar;
      };
      __spreadArrays = function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      };
      __spreadArray = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || from);
      };
      __await = function(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? {value: __await(o[n](v)), done: n === "return"} : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({value: v2, done: d});
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", {value: raw});
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", {enumerable: true, value: v});
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : {"default": mod};
      };
      __classPrivateFieldGet = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__spreadArray", __spreadArray);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// ../../node_modules/lower-case/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/lower-case/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.lowerCase = exports.localeLowerCase = void 0;
    var SUPPORTED_LOCALE = {
      tr: {
        regexp: /\u0130|\u0049|\u0049\u0307/g,
        map: {
          \u0130: "i",
          I: "\u0131",
          I\u0307: "i"
        }
      },
      az: {
        regexp: /\u0130/g,
        map: {
          \u0130: "i",
          I: "\u0131",
          I\u0307: "i"
        }
      },
      lt: {
        regexp: /\u0049|\u004A|\u012E|\u00CC|\u00CD|\u0128/g,
        map: {
          I: "i\u0307",
          J: "j\u0307",
          \u012E: "\u012F\u0307",
          \u00CC: "i\u0307\u0300",
          \u00CD: "i\u0307\u0301",
          \u0128: "i\u0307\u0303"
        }
      }
    };
    function localeLowerCase(str, locale) {
      var lang = SUPPORTED_LOCALE[locale.toLowerCase()];
      if (lang)
        return lowerCase(str.replace(lang.regexp, function(m) {
          return lang.map[m];
        }));
      return lowerCase(str);
    }
    exports.localeLowerCase = localeLowerCase;
    function lowerCase(str) {
      return str.toLowerCase();
    }
    exports.lowerCase = lowerCase;
  }
});

// ../../node_modules/no-case/dist/index.js
var require_dist2 = __commonJS({
  "../../node_modules/no-case/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.noCase = void 0;
    var lower_case_1 = require_dist();
    var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
    var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
    function noCase(input, options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.splitRegexp, splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform2 = _c === void 0 ? lower_case_1.lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? " " : _d;
      var result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
      var start = 0;
      var end = result.length;
      while (result.charAt(start) === "\0")
        start++;
      while (result.charAt(end - 1) === "\0")
        end--;
      return result.slice(start, end).split("\0").map(transform2).join(delimiter);
    }
    exports.noCase = noCase;
    function replace(input, re, value) {
      if (re instanceof RegExp)
        return input.replace(re, value);
      return re.reduce(function(input2, re2) {
        return input2.replace(re2, value);
      }, input);
    }
  }
});

// ../../node_modules/pascal-case/dist/index.js
var require_dist3 = __commonJS({
  "../../node_modules/pascal-case/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.pascalCase = exports.pascalCaseTransformMerge = exports.pascalCaseTransform = void 0;
    var tslib_1 = require_tslib();
    var no_case_1 = require_dist2();
    function pascalCaseTransform(input, index) {
      var firstChar = input.charAt(0);
      var lowerChars = input.substr(1).toLowerCase();
      if (index > 0 && firstChar >= "0" && firstChar <= "9") {
        return "_" + firstChar + lowerChars;
      }
      return "" + firstChar.toUpperCase() + lowerChars;
    }
    exports.pascalCaseTransform = pascalCaseTransform;
    function pascalCaseTransformMerge(input) {
      return input.charAt(0).toUpperCase() + input.slice(1).toLowerCase();
    }
    exports.pascalCaseTransformMerge = pascalCaseTransformMerge;
    function pascalCase(input, options) {
      if (options === void 0) {
        options = {};
      }
      return no_case_1.noCase(input, tslib_1.__assign({delimiter: "", transform: pascalCaseTransform}, options));
    }
    exports.pascalCase = pascalCase;
  }
});

// ../../node_modules/camel-case/dist/index.js
var require_dist4 = __commonJS({
  "../../node_modules/camel-case/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.camelCase = exports.camelCaseTransformMerge = exports.camelCaseTransform = void 0;
    var tslib_1 = require_tslib();
    var pascal_case_1 = require_dist3();
    function camelCaseTransform(input, index) {
      if (index === 0)
        return input.toLowerCase();
      return pascal_case_1.pascalCaseTransform(input, index);
    }
    exports.camelCaseTransform = camelCaseTransform;
    function camelCaseTransformMerge(input, index) {
      if (index === 0)
        return input.toLowerCase();
      return pascal_case_1.pascalCaseTransformMerge(input);
    }
    exports.camelCaseTransformMerge = camelCaseTransformMerge;
    function camelCase2(input, options) {
      if (options === void 0) {
        options = {};
      }
      return pascal_case_1.pascalCase(input, tslib_1.__assign({transform: camelCaseTransform}, options));
    }
    exports.camelCase = camelCase2;
  }
});

// src/compiler/index.ts
import "source-map-support/register.js";
import path4 from "path";
import {renderMarkdownWithFrontmatter} from "@astrojs/markdown-support";
import {parse as parse2} from "@astrojs/parser";

// src/compiler/transform/index.ts
import {walk} from "estree-walker";

// src/compiler/transform/styles.ts
import crypto from "crypto";
import {createRequire} from "module";
import path from "path";
import autoprefixer from "autoprefixer";
import postcss from "postcss";
import postcssKeyframes from "postcss-icss-keyframes";
import findUp from "find-up";
import sass from "sass";

// src/logger.ts
import "source-map-support/register.js";
import {bold, blue, red, grey, underline, yellow} from "kleur/colors";
import {Writable} from "stream";
import {format as utilFormat} from "util";
import stringWidth from "string-width";
var defaultLogDestination = new Writable({
  objectMode: true,
  write(event, _, callback) {
    let dest = process.stderr;
    if (levels[event.level] < levels["error"]) {
      dest = process.stdout;
    }
    let type = event.type;
    if (type !== null) {
      if (event.level === "info") {
        type = bold(blue(type));
      } else if (event.level === "warn") {
        type = bold(yellow(type));
      } else if (event.level === "error") {
        type = bold(red(type));
      }
      dest.write(`[${type}] `);
    }
    dest.write(utilFormat(...event.args));
    dest.write("\n");
    callback();
  }
});
var defaultLogOptions = {
  dest: defaultLogDestination,
  level: "info"
};
var levels = {
  debug: 20,
  info: 30,
  warn: 40,
  error: 50,
  silent: 90
};
function log(opts = defaultLogOptions, level, type, ...args) {
  const event = {
    type,
    level,
    args,
    message: ""
  };
  if (levels[opts.level] > levels[level]) {
    return;
  }
  opts.dest.write(event);
}
function debug(opts, type, ...messages) {
  return log(opts, "debug", type, ...messages);
}
function info(opts, type, ...messages) {
  return log(opts, "info", type, ...messages);
}
function warn(opts, type, ...messages) {
  return log(opts, "warn", type, ...messages);
}
function error(opts, type, ...messages) {
  return log(opts, "error", type, ...messages);
}
function parseError(opts, err) {
  if (!err.frame) {
    return error(opts, "parse-error", err.message || err);
  }
  let frame = err.frame.replace(/^([0-9]+)(:)/gm, `${bold("$1")} \u2502`).replace(/(?<=^\s+)(\^)/gm, bold(red(" ^"))).replace(/^/gm, "   ");
  error(opts, "parse-error", `

 ${underline(bold(grey(`${err.filename || ""}:${err.start.line}:${err.start.column}`)))}

 ${bold(red(`\u{1D605} ${err.message}`))}

${frame}
`);
}
var logger = {
  debug: debug.bind(null, defaultLogOptions),
  info: info.bind(null, defaultLogOptions),
  warn: warn.bind(null, defaultLogOptions),
  error: error.bind(null, defaultLogOptions)
};
var defaultLogLevel;
if (process.argv.includes("--verbose")) {
  defaultLogLevel = "debug";
} else if (process.argv.includes("--silent")) {
  defaultLogLevel = "silent";
} else {
  defaultLogLevel = "info";
}

// src/compiler/transform/postcss-scoped-styles/index.ts
var CSS_SEPARATORS = new Set([" ", ",", "+", ">", "~"]);
var KEYFRAME_PERCENT = /\d+\.?\d*%/;
var NEVER_SCOPED_TAGS = new Set(["base", "body", "font", "frame", "frameset", "head", "html", "link", "meta", "noframes", "noscript", "script", "style", "title"]);
function scopeRule(selector, className) {
  if (selector === "from" || selector === "to" || KEYFRAME_PERCENT.test(selector)) {
    return selector;
  }
  const c = className.replace(/^\.?/, ".");
  const selectors = [];
  let ss = selector;
  {
    let start = 0;
    let lastValue = "";
    let parensOpen = false;
    for (let n = 0; n < ss.length; n++) {
      const isEnd = n === selector.length - 1;
      if (selector[n] === "(")
        parensOpen = true;
      if (selector[n] === ")")
        parensOpen = false;
      if (isEnd || parensOpen === false && CSS_SEPARATORS.has(selector[n])) {
        lastValue = selector.substring(start, isEnd ? void 0 : n);
        if (!lastValue)
          continue;
        selectors.push({start, end: isEnd ? n + 1 : n, value: lastValue});
        start = n + 1;
      }
    }
  }
  for (let i = selectors.length - 1; i >= 0; i--) {
    const {start, end, value} = selectors[i];
    const head = ss.substring(0, start);
    const tail = ss.substring(end);
    if (value === "*") {
      ss = head + c + tail;
      continue;
    }
    if (value.startsWith(":global(")) {
      ss = head + ss.substring(start, end).replace(/^:global\(/, "").replace(/\)$/, "") + tail;
      continue;
    }
    if (CSS_SEPARATORS.has(value) || NEVER_SCOPED_TAGS.has(value)) {
      ss = head + value + tail;
      continue;
    }
    let newSelector = value;
    const pseudoIndex = newSelector.search(/(?<!\\):/);
    if (pseudoIndex > 0) {
      ss = head + newSelector.substring(0, pseudoIndex) + c + newSelector.substr(pseudoIndex) + tail;
    } else {
      ss = head + newSelector + c + tail;
    }
  }
  return ss;
}
function astroScopedStyles(options) {
  const rulesScopedCache = new WeakSet();
  return {
    postcssPlugin: "@astrojs/postcss-scoped-styles",
    Rule(rule) {
      if (!rulesScopedCache.has(rule)) {
        rule.selector = scopeRule(rule.selector, options.className);
        rulesScopedCache.add(rule);
      }
    }
  };
}

// src/compiler/transform/styles.ts
import slash from "slash";
var getStyleType = new Map([
  [".css", "css"],
  [".pcss", "postcss"],
  [".sass", "sass"],
  [".scss", "scss"],
  ["css", "css"],
  ["sass", "sass"],
  ["scss", "scss"],
  ["text/css", "css"],
  ["text/sass", "sass"],
  ["text/scss", "scss"]
]);
function hashFromFilename(filename) {
  const hash = crypto.createHash("sha256");
  return hash.update(slash(filename)).digest("base64").toString().replace(/[^A-Za-z0-9-]/g, "").substr(0, 8);
}
var miniCache = {
  nodeModules: new Map()
};
function hasClass(classList, className) {
  if (!className)
    return false;
  for (const c of classList.split(" ")) {
    if (className === c.trim())
      return true;
  }
  return false;
}
async function transformStyle(code, {logging, type, filename, scopedClass, tailwindConfig}) {
  let styleType = "css";
  if (type) {
    styleType = getStyleType.get(type) || styleType;
  }
  let includePaths = [path.dirname(filename)];
  const cachedNodeModulesDir = miniCache.nodeModules.get(filename);
  if (cachedNodeModulesDir) {
    includePaths.push(cachedNodeModulesDir);
  } else {
    const nodeModulesDir = await findUp("node_modules", {type: "directory", cwd: path.dirname(filename)});
    if (nodeModulesDir) {
      miniCache.nodeModules.set(filename, nodeModulesDir);
      includePaths.push(nodeModulesDir);
    }
  }
  let css = "";
  switch (styleType) {
    case "css": {
      css = code;
      break;
    }
    case "sass":
    case "scss": {
      css = sass.renderSync({data: code, includePaths}).css.toString("utf8");
      break;
    }
    default: {
      throw new Error(`Unsupported: <style lang="${styleType}">`);
    }
  }
  const postcssPlugins = [];
  if (tailwindConfig) {
    try {
      const require2 = createRequire(import.meta.url);
      const tw = require2.resolve("tailwindcss", {paths: [import.meta.url, process.cwd()]});
      postcssPlugins.push(require2(tw)(tailwindConfig));
    } catch (err) {
      error(logging, "transform", err);
      throw new Error(`tailwindcss not installed. Try running \`npm install tailwindcss\` and trying again.`);
    }
  }
  postcssPlugins.push(astroScopedStyles({className: scopedClass}));
  postcssPlugins.push(postcssKeyframes({
    generateScopedName(keyframesName) {
      return `${keyframesName}-${scopedClass}`;
    }
  }));
  postcssPlugins.push(autoprefixer());
  css = await postcss(postcssPlugins).process(css, {from: filename, to: void 0}).then((result) => result.css);
  return {css, type: styleType};
}
function injectScopedClassAttribute(node, scopedClass, attribute = "class") {
  if (!node.attributes)
    node.attributes = [];
  const classIndex = node.attributes.findIndex(({name}) => name === attribute);
  if (classIndex === -1) {
    node.attributes.push({start: -1, end: -1, type: "Attribute", name: attribute, value: [{type: "Text", raw: scopedClass, data: scopedClass}]});
  } else {
    const attr = node.attributes[classIndex];
    for (let k = 0; k < attr.value.length; k++) {
      if (attr.value[k].type === "Text") {
        if (!hasClass(attr.value[k].data, scopedClass)) {
          attr.value[k].raw += " " + scopedClass;
          attr.value[k].data += " " + scopedClass;
        }
      } else if (attr.value[k].type === "MustacheTag" && attr.value[k]) {
        if (!attr.value[k].expression.codeChunks[0].includes(`' ${scopedClass}'`)) {
          attr.value[k].expression.codeChunks[0] = `(${attr.value[k].expression.codeChunks[0]}) + ' ${scopedClass}'`;
        }
      }
    }
  }
}
function transformStyles({compileOptions, filename, fileID}) {
  const styleNodes = [];
  const styleTransformPromises = [];
  const scopedClass = `astro-${hashFromFilename(fileID)}`;
  const nodesToScope = new Set();
  return {
    visitors: {
      html: {
        InlineComponent: {
          enter(node) {
            if (node.name === "Markdown") {
              injectScopedClassAttribute(node, scopedClass, "$scope");
            }
            for (let attr of node.attributes) {
              if (attr.name === "class") {
                injectScopedClassAttribute(node, scopedClass, "class");
                break;
              }
            }
          }
        },
        Element: {
          enter(node) {
            if (node.name === "style") {
              const code = Array.isArray(node.children) ? node.children.map(({data}) => data).join("\n") : "";
              if (!code)
                return;
              const langAttr = (node.attributes || []).find(({name}) => name === "lang");
              styleNodes.push(node);
              styleTransformPromises.push(transformStyle(code, {
                logging: compileOptions.logging,
                type: langAttr && langAttr.value[0] && langAttr.value[0].data || void 0,
                filename,
                scopedClass,
                tailwindConfig: compileOptions.astroConfig.devOptions.tailwindConfig
              }));
              return;
            }
            if (NEVER_SCOPED_TAGS.has(node.name) || node.name.toLowerCase() === "!doctype") {
              return;
            }
            nodesToScope.add(node);
          }
        }
      },
      css: {
        Style: {
          enter(node) {
            if (!node.content || !node.content.styles)
              return;
            const code = node.content.styles;
            const langAttr = (node.attributes || []).find(({name}) => name === "lang");
            styleNodes.push(node);
            styleTransformPromises.push(transformStyle(code, {
              logging: compileOptions.logging,
              type: langAttr && langAttr.value[0] && langAttr.value[0].data || void 0,
              filename,
              scopedClass
            }));
          }
        }
      }
    },
    async finalize() {
      const styleTransforms = await Promise.all(styleTransformPromises);
      if (styleTransforms.length > 0) {
        for (const node of nodesToScope.values()) {
          injectScopedClassAttribute(node, scopedClass);
        }
      }
      styleTransforms.forEach((result, n) => {
        if (styleNodes[n].attributes) {
          const isHeadStyle = !styleNodes[n].content;
          if (isHeadStyle) {
            styleNodes[n].children = [__spreadProps(__spreadValues({}, styleNodes[n].children[0]), {data: result.css})];
          } else {
            styleNodes[n].content.styles = result.css;
          }
          const styleTypeIndex = styleNodes[n].attributes.findIndex(({name}) => name === "type");
          if (styleTypeIndex !== -1) {
            styleNodes[n].attributes[styleTypeIndex].value[0].raw = "text/css";
            styleNodes[n].attributes[styleTypeIndex].value[0].data = "text/css";
          } else {
            styleNodes[n].attributes.push({name: "type", type: "Attribute", value: [{type: "Text", raw: "text/css", data: "text/css"}]});
          }
          const styleLangIndex = styleNodes[n].attributes.findIndex(({name}) => name === "lang");
          if (styleLangIndex !== -1)
            styleNodes[n].attributes.splice(styleLangIndex, 1);
        }
      });
    }
  };
}

// src/compiler/transform/doctype.ts
function doctype_default(_opts) {
  let hasDoctype = false;
  return {
    visitors: {
      html: {
        Element: {
          enter(node, parent, _key, index) {
            if (node.name.toLowerCase() === "!doctype") {
              hasDoctype = true;
            }
            if (node.name === "html" && !hasDoctype) {
              const dtNode = {
                start: 0,
                end: 0,
                attributes: [{type: "Attribute", name: "html", value: true, start: 0, end: 0}],
                children: [],
                name: "!doctype",
                type: "Element"
              };
              (parent.children || []).splice(index, 0, dtNode);
              hasDoctype = true;
            }
          }
        }
      }
    },
    async finalize() {
    }
  };
}

// src/ast.ts
import "source-map-support/register.js";
function getAttr(attributes, name) {
  const attr = attributes.find((a) => a.name === name);
  return attr;
}
function getAttrValue(attributes, name) {
  var _a;
  if (attributes.length === 0)
    return "";
  const attr = getAttr(attributes, name);
  if (attr) {
    return (_a = attr.value[0]) == null ? void 0 : _a.data;
  }
}
function setAttrValue(attributes, name, value) {
  const attr = attributes.find((a) => a.name === name);
  if (attr && attr.value[0]) {
    attr.value[0].data = value;
    attr.value[0].raw = value;
  }
}

// src/compiler/transform/module-scripts.ts
function module_scripts_default({compileOptions, filename}) {
  const {astroConfig} = compileOptions;
  const fileUrl = new URL(`file://${filename}`);
  return {
    visitors: {
      html: {
        Element: {
          enter(node) {
            let name = node.name;
            if (name !== "script") {
              return;
            }
            let type = getAttrValue(node.attributes, "type");
            if (type !== "module") {
              return;
            }
            let src = getAttrValue(node.attributes, "src");
            if (!src) {
              return;
            }
            if (src.startsWith("/")) {
              return;
            }
            try {
              new URL(src);
              return;
            } catch (err) {
            }
            const srcUrl = new URL(src, fileUrl);
            const absoluteUrl = `/_astro/${srcUrl.href.replace(astroConfig.projectRoot.href, "")}`;
            setAttrValue(node.attributes, "src", absoluteUrl);
          }
        }
      }
    },
    async finalize() {
    }
  };
}

// src/compiler/transform/prism.ts
var PRISM_IMPORT = `import Prism from 'astro/components/Prism.astro';`;
var prismImportExp = /import Prism from ['"]astro\/components\/Prism.astro['"]/;
function escape(code) {
  return code.replace(/[`$]/g, (match) => {
    return "\\" + match;
  }).replace(/&#123;/g, "{");
}
function unescapeCode(code) {
  var _a;
  code.children = (_a = code.children) == null ? void 0 : _a.map((child) => {
    if (child.type === "Text") {
      return __spreadProps(__spreadValues({}, child), {raw: child.raw.replace(/&#x26;#123;/g, "{")});
    }
    return child;
  });
}
function prism_default(module) {
  let usesPrism = false;
  return {
    visitors: {
      html: {
        Element: {
          enter(node) {
            if (node.name === "code") {
              unescapeCode(node);
              return;
            }
            if (node.name !== "pre")
              return;
            const codeEl = node.children && node.children[0];
            if (!codeEl || codeEl.name !== "code")
              return;
            const className = getAttrValue(codeEl.attributes, "class") || "";
            const classes = className.split(" ");
            let lang;
            for (let cn of classes) {
              const matches = /language-(.+)/.exec(cn);
              if (matches) {
                lang = matches[1];
              }
            }
            if (!lang)
              return;
            let codeData = codeEl.children && codeEl.children[0];
            if (!codeData)
              return;
            let code = codeData.data;
            const repl = {
              start: 0,
              end: 0,
              type: "InlineComponent",
              name: "Prism",
              attributes: [
                {
                  type: "Attribute",
                  name: "lang",
                  value: [
                    {
                      type: "Text",
                      raw: lang,
                      data: lang
                    }
                  ]
                },
                {
                  type: "Attribute",
                  name: "code",
                  value: [
                    {
                      type: "MustacheTag",
                      expression: {
                        type: "Expression",
                        codeChunks: ["`" + escape(code) + "`"],
                        children: []
                      }
                    }
                  ]
                }
              ],
              children: []
            };
            this.replace(repl);
            usesPrism = true;
          }
        }
      }
    },
    async finalize() {
      if (usesPrism && module && !prismImportExp.test(module.content)) {
        module.content = PRISM_IMPORT + "\n" + module.content;
      }
    }
  };
}

// src/compiler/transform/util/end-of-head.ts
var validHeadElements = new Set(["!doctype", "title", "meta", "link", "style", "script", "noscript", "base"]);
var EndOfHead = class {
  constructor() {
    this.head = null;
    this.firstNonHead = null;
    this.parent = null;
    this.stack = [];
    this.append = () => void 0;
  }
  get found() {
    return !!(this.head || this.firstNonHead);
  }
  enter(node) {
    if (this.found) {
      return;
    }
    this.stack.push(node);
    if (!node.name) {
      return;
    }
    const name = node.name.toLowerCase();
    if (name === "head") {
      this.head = node;
      this.parent = this.stack[this.stack.length - 2];
      this.append = this.appendToHead;
      return;
    }
    if (!validHeadElements.has(name)) {
      this.firstNonHead = node;
      this.parent = this.stack[this.stack.length - 2];
      this.append = this.prependToFirstNonHead;
      return;
    }
  }
  leave(_node) {
    this.stack.pop();
  }
  appendToHead(...nodes) {
    var _a;
    const head = this.head;
    head.children = (_a = head.children) != null ? _a : [];
    head.children.push(...nodes);
  }
  prependToFirstNonHead(...nodes) {
    var _a, _b, _c;
    let idx = ((_a = this.parent) == null ? void 0 : _a.children.indexOf(this.firstNonHead)) || 0;
    (_c = (_b = this.parent) == null ? void 0 : _b.children) == null ? void 0 : _c.splice(idx, 0, ...nodes);
  }
};

// src/compiler/transform/head.ts
function head_default(opts) {
  let hasComponents = false;
  let isHmrEnabled = typeof opts.compileOptions.hmrPort !== "undefined" && opts.compileOptions.mode === "development";
  const eoh = new EndOfHead();
  return {
    visitors: {
      html: {
        Fragment: {
          enter(node) {
            eoh.enter(node);
          },
          leave(node) {
            eoh.leave(node);
          }
        },
        InlineComponent: {
          enter(node) {
            if (hasComponents) {
              return;
            }
            eoh.enter(node);
            if (node.attributes && node.attributes.some(({name}) => name.startsWith("client:"))) {
              hasComponents = true;
              return;
            }
            const [_name, kind] = node.name.split(":");
            if (kind) {
              hasComponents = true;
            }
          },
          leave(node) {
            eoh.leave(node);
          }
        },
        Element: {
          enter(node) {
            eoh.enter(node);
          },
          leave(node) {
            eoh.leave(node);
          }
        }
      }
    },
    async finalize() {
      const children = [];
      children.push({
        start: 0,
        end: 0,
        type: "Fragment",
        children: [
          {
            start: 0,
            end: 0,
            type: "Expression",
            codeChunks: ["Astro.css.map(css => (", "))"],
            children: [
              {
                type: "Element",
                name: "link",
                attributes: [
                  {
                    name: "rel",
                    type: "Attribute",
                    value: [
                      {
                        type: "Text",
                        raw: "stylesheet",
                        data: "stylesheet"
                      }
                    ]
                  },
                  {
                    name: "href",
                    type: "Attribute",
                    value: [
                      {
                        start: 0,
                        end: 0,
                        type: "MustacheTag",
                        expression: {
                          start: 0,
                          end: 0,
                          type: "Expression",
                          codeChunks: ["css"],
                          children: []
                        }
                      }
                    ]
                  }
                ],
                start: 0,
                end: 0,
                children: []
              }
            ]
          }
        ]
      });
      if (hasComponents) {
        children.push({
          type: "Element",
          name: "style",
          attributes: [{name: "type", type: "Attribute", value: [{type: "Text", raw: "text/css", data: "text/css"}]}],
          start: 0,
          end: 0,
          children: [
            {
              start: 0,
              end: 0,
              type: "Text",
              data: "astro-root, astro-fragment { display: contents; }",
              raw: "astro-root, astro-fragment { display: contents; }"
            }
          ]
        });
      }
      if (isHmrEnabled) {
        const {hmrPort} = opts.compileOptions;
        children.push({
          type: "Element",
          name: "script",
          attributes: [],
          children: [{type: "Text", data: `window.HMR_WEBSOCKET_PORT = ${hmrPort};`, start: 0, end: 0}],
          start: 0,
          end: 0
        }, {
          type: "Element",
          name: "script",
          attributes: [
            {type: "Attribute", name: "type", value: [{type: "Text", data: "module", start: 0, end: 0}], start: 0, end: 0},
            {type: "Attribute", name: "src", value: [{type: "Text", data: "/_snowpack/hmr-client.js", start: 0, end: 0}], start: 0, end: 0}
          ],
          children: [],
          start: 0,
          end: 0
        });
      }
      const conditionalNode = {
        start: 0,
        end: 0,
        type: "Expression",
        codeChunks: ["Astro.isPage ? (", ") : null"],
        children: [
          {
            start: 0,
            end: 0,
            type: "Fragment",
            children
          }
        ]
      };
      eoh.append(conditionalNode);
    }
  };
}

// src/compiler/transform/index.ts
function addVisitor(visitor, collection, nodeName, event) {
  if (typeof visitor[event] !== "function")
    return;
  if (!collection[event])
    collection[event] = new Map();
  const visitors = collection[event].get(nodeName) || [];
  visitors.push(visitor[event]);
  collection[event].set(nodeName, visitors);
}
function collectVisitors(transformer, htmlVisitors, cssVisitors, finalizers) {
  if (transformer.visitors) {
    if (transformer.visitors.html) {
      for (const [nodeName, visitor] of Object.entries(transformer.visitors.html)) {
        addVisitor(visitor, htmlVisitors, nodeName, "enter");
        addVisitor(visitor, htmlVisitors, nodeName, "leave");
      }
    }
    if (transformer.visitors.css) {
      for (const [nodeName, visitor] of Object.entries(transformer.visitors.css)) {
        addVisitor(visitor, cssVisitors, nodeName, "enter");
        addVisitor(visitor, cssVisitors, nodeName, "leave");
      }
    }
  }
  finalizers.push(transformer.finalize);
}
function createVisitorCollection() {
  return {
    enter: new Map(),
    leave: new Map()
  };
}
function walkAstWithVisitors(tmpl, collection) {
  walk(tmpl, {
    enter(node, parent, key, index) {
      if (collection.enter.has(node.type)) {
        const fns = collection.enter.get(node.type) || [];
        for (let fn of fns) {
          fn.call(this, node, parent, key, index);
        }
      }
    },
    leave(node, parent, key, index) {
      if (collection.leave.has(node.type)) {
        const fns = collection.leave.get(node.type) || [];
        for (let fn of fns) {
          fn.call(this, node, parent, key, index);
        }
      }
    }
  });
}
async function transform(ast, opts) {
  const htmlVisitors = createVisitorCollection();
  const cssVisitors = createVisitorCollection();
  const finalizers = [];
  const optimizers = [head_default(opts), transformStyles(opts), doctype_default(opts), module_scripts_default(opts), prism_default(ast.module)];
  for (const optimizer of optimizers) {
    collectVisitors(optimizer, htmlVisitors, cssVisitors, finalizers);
  }
  walkAstWithVisitors(ast.css, cssVisitors);
  walkAstWithVisitors(ast.html, htmlVisitors);
  await Promise.all(finalizers.map((fn) => fn()));
}

// src/compiler/codegen/index.ts
import "source-map-support/register.js";
import eslexer from "es-module-lexer";
import esbuild from "esbuild";
import path3 from "path";
import {parse, FEATURE_CUSTOM_ELEMENT} from "@astrojs/parser";
import {walk as walk2, asyncWalk} from "estree-walker";
import _babelGenerator from "@babel/generator";
import babelParser from "@babel/parser";
import {codeFrameColumns} from "@babel/code-frame";
import {
  default as default2
} from "@babel/traverse";

// src/compiler/codegen/content.ts
import path2 from "path";
import glob from "tiny-glob/sync.js";
import slash2 from "slash";
function globSearch(spec, {filename}) {
  try {
    const cwd = path2.dirname(filename);
    let found = glob(spec, {cwd, filesOnly: true});
    if (!found.length) {
      throw new Error(`No files matched "${spec}" from ${filename}`);
    }
    return found.map((f) => slash2(f[0] === "." ? f : `./${f}`));
  } catch (err) {
    throw new Error(`No files matched "${spec}" from ${filename}`);
  }
}
function fetchContent(spec, {namespace, filename}) {
  let code = "";
  const imports = new Set();
  const importPaths = globSearch(spec, {filename});
  importPaths.forEach((importPath, j) => {
    const id = `${namespace}_${j}`;
    imports.add(`import { __content as ${id} } from '${importPath}';`);
    const fullPath = path2.resolve(path2.dirname(filename), importPath);
    if (fullPath.includes(`${path2.sep}pages${path2.sep}`)) {
      const url = importPath.replace(/^\./, "").replace(/\.md$/, "");
      imports.add(`${id}.url = '${url}';`);
    }
  });
  code += `${namespace} = [${importPaths.map((_, j) => `${namespace}_${j}`).join(",")}];
`;
  return {imports, code};
}

// src/compiler/codegen/utils.ts
function isFetchContent(declaration) {
  let {init} = declaration;
  if (!init)
    return false;
  if (init.type === "AwaitExpression") {
    init = init.argument;
  }
  if (init.type !== "CallExpression" || init.callee.type !== "MemberExpression" || init.callee.object.name !== "Astro" || init.callee.property.name !== "fetchContent")
    return false;
  return true;
}

// src/compiler/codegen/index.ts
import {yellow as yellow2} from "kleur/colors";

// src/compiler/utils.ts
function isCustomElementTag(tag) {
  return /[-]/.test(tag);
}
function isComponentTag(tag) {
  return /^[A-Z]/.test(tag) || /^[a-z]+\./.test(tag) || isCustomElementTag(tag);
}
function clamp(num, min, max) {
  return Math.max(min, Math.min(max, num));
}
function positionAt(offset, text) {
  offset = clamp(offset, 0, text.length);
  const lineOffsets = getLineOffsets(text);
  let low = 0;
  let high = lineOffsets.length;
  if (high === 0) {
    return {line: 0, character: offset};
  }
  while (low < high) {
    const mid = Math.floor((low + high) / 2);
    if (lineOffsets[mid] > offset) {
      high = mid;
    } else {
      low = mid + 1;
    }
  }
  const line = low - 1;
  return {line, character: offset - lineOffsets[line]};
}
function getLineOffsets(text) {
  const lineOffsets = [];
  let isLineStart = true;
  for (let i = 0; i < text.length; i++) {
    if (isLineStart) {
      lineOffsets.push(i);
      isLineStart = false;
    }
    const ch = text.charAt(i);
    isLineStart = ch === "\r" || ch === "\n";
    if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
      i++;
    }
  }
  if (isLineStart && text.length > 0) {
    lineOffsets.push(text.length);
  }
  return lineOffsets;
}

// src/compiler/codegen/index.ts
var import_camel_case = __toModule(require_dist4());
import {renderMarkdown} from "@astrojs/markdown-support";

// src/node_builtins.ts
import {builtinModules} from "module";
var nodeBuiltinsSet = new Set(builtinModules);
var nodeBuiltinsMap = new Map(builtinModules.map((bareName) => [bareName, "node:" + bareName]));

// src/compiler/codegen/index.ts
import {readFileSync} from "fs";
import {pathToFileURL} from "url";
var traverse = default2.default;
var babelGenerator = _babelGenerator.default;
var {transformSync} = esbuild;
function findHydrationAttributes(attrs) {
  let method;
  const hydrationDirectives = new Set(["client:load", "client:idle", "client:visible"]);
  for (const [key, val] of Object.entries(attrs)) {
    if (hydrationDirectives.has(key))
      method = key.slice(7);
  }
  return {method};
}
async function getAttributes(attrs, state, compileOptions) {
  let result = {};
  for (const attr of attrs) {
    if (attr.type === "Spread") {
      const code = await compileExpression(attr.expression, state, compileOptions);
      if (code) {
        result[`...(${code})`] = "";
      }
      continue;
    }
    if (attr.value === true) {
      result[attr.name] = JSON.stringify(attr.value);
      continue;
    }
    if (attr.value === false || attr.value === void 0) {
      continue;
    }
    if (attr.value.length === 0) {
      result[attr.name] = '""';
      continue;
    }
    if (attr.value.length > 1) {
      result[attr.name] = "(" + attr.value.map((v) => {
        if (v.content) {
          return v.content;
        } else {
          return JSON.stringify(getTextFromAttribute(v));
        }
      }).join("+") + ")";
      continue;
    }
    const val = attr.value[0];
    if (!val) {
      result[attr.name] = "(" + val + ")";
      continue;
    }
    switch (val.type) {
      case "MustacheTag": {
        const code = await compileExpression(val.expression, state, compileOptions);
        if (code) {
          result[attr.name] = "(" + code + ")";
        }
        continue;
      }
      case "Text":
        result[attr.name] = JSON.stringify(getTextFromAttribute(val));
        continue;
      case "AttributeShorthand":
        result[attr.name] = "(" + attr.name + ")";
        continue;
      default:
        throw new Error(`UNKNOWN: ${val.type}`);
    }
  }
  return result;
}
function getTextFromAttribute(attr) {
  switch (attr.type) {
    case "Text": {
      if (attr.raw !== void 0) {
        return attr.raw;
      }
      if (attr.data !== void 0) {
        return attr.data;
      }
      break;
    }
    case "MustacheTag": {
      return attr.expression.codeChunks[0];
    }
  }
  throw new Error(`Unknown attribute type ${attr.type}`);
}
function generateAttributes(attrs) {
  let result = "{";
  for (const [key, val] of Object.entries(attrs)) {
    if (key.startsWith("...")) {
      result += key + ",";
    } else {
      result += JSON.stringify(key) + ":" + val + ",";
    }
  }
  return result + "}";
}
function getComponentUrl(astroConfig, url, parentUrl) {
  const componentExt = path3.extname(url);
  const ext = PlainExtensions.has(componentExt) ? ".js" : `${componentExt}.js`;
  const outUrl = new URL(url, parentUrl);
  return "/_astro/" + outUrl.href.replace(astroConfig.projectRoot.href, "").replace(/\.[^.]+$/, ext);
}
var PlainExtensions = new Set([".js", ".jsx", ".ts", ".tsx"]);
function getComponentWrapper(_name, hydration, {url, importSpecifier}, opts) {
  const {astroConfig, filename} = opts;
  let name = _name;
  let method = hydration.method;
  if (name.indexOf(":") > 0) {
    const [legacyName, legacyMethod] = _name.split(":");
    name = legacyName;
    method = legacyMethod;
    const {compileOptions, filename: filename2} = opts;
    const shortname = path3.posix.relative(compileOptions.astroConfig.projectRoot.pathname, filename2);
    warn(compileOptions.logging, shortname, yellow2(`Deprecation warning: Partial hydration now uses a directive syntax. Please update to "<${name} client:${method} />"`));
  }
  if (isCustomElementTag(_name)) {
    return {
      wrapper: `__astro_component(...__astro_element_registry.astroComponentArgs("${name}", ${JSON.stringify({hydrate: method, displayName: _name})}))`,
      wrapperImports: [
        `import {AstroElementRegistry} from 'astro/dist/internal/element-registry.js';`,
        `import {__astro_component} from 'astro/dist/internal/__astro_component.js';`
      ]
    };
  } else {
    const getComponentExport = () => {
      switch (importSpecifier.type) {
        case "ImportDefaultSpecifier":
          return {value: "default"};
        case "ImportSpecifier": {
          if (importSpecifier.imported.type === "Identifier") {
            return {value: importSpecifier.imported.name};
          }
          return {value: importSpecifier.imported.value};
        }
        case "ImportNamespaceSpecifier": {
          const [_, value] = _name.split(".");
          return {value};
        }
      }
    };
    const importInfo = method ? {
      componentUrl: getComponentUrl(astroConfig, url, pathToFileURL(filename)),
      componentExport: getComponentExport()
    } : {};
    return {
      wrapper: `__astro_component(${name}, ${JSON.stringify(__spreadValues({hydrate: method, displayName: _name}, importInfo))})`,
      wrapperImports: [`import {__astro_component} from 'astro/dist/internal/__astro_component.js';`]
    };
  }
}
async function compileExpression(node, state, compileOptions) {
  var _a;
  const children = await Promise.all(((_a = node.children) != null ? _a : []).map((child) => compileHtml(child, state, compileOptions)));
  let raw = "";
  let nextChildIndex = 0;
  for (const chunk of node.codeChunks) {
    raw += chunk;
    if (nextChildIndex < children.length) {
      raw += children[nextChildIndex++];
    }
  }
  const location = {start: node.start, end: node.end};
  let code = transpileExpressionSafe("(" + raw + ")", {state, compileOptions, location});
  if (code === null)
    throw new Error(`Unable to compile expression`);
  code = code.trim().replace(/\;$/, "");
  return code;
}
function transpileExpressionSafe(raw, {state, compileOptions, location}) {
  try {
    let {code} = transformSync(raw, {
      loader: "tsx",
      jsxFactory: "h",
      jsxFragment: "Fragment",
      charset: "utf8"
    });
    return code;
  } catch ({errors}) {
    const err = new Error();
    const e = errors[0];
    err.filename = state.filename;
    const text = readFileSync(state.filename).toString();
    const start = positionAt(location.start, text);
    start.line += e.location.line;
    start.character += e.location.column + 1;
    err.start = {line: start.line, column: start.character};
    const end = __spreadValues({}, start);
    end.character += e.location.length;
    const frame = codeFrameColumns(text, {
      start: {line: start.line, column: start.character},
      end: {line: end.line, column: end.character}
    });
    err.frame = frame;
    err.message = e.text;
    parseError(compileOptions.logging, err);
    return null;
  }
}
function compileModule(ast, module, state, compileOptions) {
  var _a, _b;
  const {astroConfig} = compileOptions;
  const {filename} = state;
  const componentImports = [];
  const componentProps = [];
  const componentExports = [];
  const contentImports = new Map();
  let script = "";
  let propsStatement = "";
  let contentCode = "";
  let createCollection = "";
  if (module) {
    const parseOptions = {
      sourceType: "module",
      plugins: ["jsx", "typescript", "topLevelAwait", "throwExpressions"]
    };
    let parseResult;
    try {
      parseResult = babelParser.parse(module.content, parseOptions);
    } catch (err) {
      const location2 = {start: err.loc};
      const frame = codeFrameColumns(module.content, location2);
      err.frame = frame;
      err.filename = state.filename;
      err.start = err.loc;
      throw err;
    }
    const program = parseResult.program;
    const {body} = program;
    let i = body.length;
    while (--i >= 0) {
      const node = body[i];
      switch (node.type) {
        case "ExportNamedDeclaration": {
          if (!node.declaration)
            break;
          if (node.declaration.type === "VariableDeclaration") {
            const declaration = node.declaration.declarations[0];
            if (declaration.id.name === "__layout" || declaration.id.name === "__content") {
              componentExports.push(node);
            } else {
              componentProps.push(declaration);
            }
          } else if (node.declaration.type === "FunctionDeclaration") {
            if (!node.declaration.id || node.declaration.id.name !== "createCollection")
              break;
            createCollection = module.content.substring(node.start || 0, node.end || 0);
          }
          body.splice(i, 1);
          break;
        }
        case "FunctionDeclaration": {
          if ((_a = node.id) == null ? void 0 : _a.name) {
            state.declarations.add((_b = node.id) == null ? void 0 : _b.name);
          }
          break;
        }
        case "ImportDeclaration": {
          componentImports.push(node);
          body.splice(i, 1);
          break;
        }
        case "VariableDeclaration": {
          for (const declaration of node.declarations) {
            if (!isFetchContent(declaration)) {
              if (declaration.id.type === "Identifier") {
                state.declarations.add(declaration.id.name);
              }
              continue;
            }
            body.splice(i, 1);
            let {id, init} = declaration;
            if (!id || !init || id.type !== "Identifier")
              continue;
            if (init.type === "AwaitExpression") {
              init = init.argument;
              const shortname = path3.posix.relative(compileOptions.astroConfig.projectRoot.pathname, state.filename);
              warn(compileOptions.logging, shortname, yellow2("awaiting Astro.fetchContent() not necessary"));
            }
            if (init.type !== "CallExpression")
              continue;
            const namespace = id.name;
            if (init.arguments[0].type !== "StringLiteral") {
              throw new Error(`[Astro.fetchContent] Only string literals allowed, ex: \`Astro.fetchContent('./post/*.md')\`
  ${state.filename}`);
            }
            const spec = init.arguments[0].value;
            if (typeof spec === "string")
              contentImports.set(namespace, {spec, declarator: node.kind});
          }
          break;
        }
      }
    }
    for (const componentImport of componentImports) {
      const importUrl = componentImport.source.value;
      if (nodeBuiltinsSet.has(importUrl)) {
        throw new Error(`Node builtins must be prefixed with 'node:'. Use node:${importUrl} instead.`);
      }
      for (const specifier of componentImport.specifiers) {
        const componentName = specifier.local.name;
        state.components.set(componentName, {
          importSpecifier: specifier,
          url: importUrl
        });
      }
      const {start, end} = componentImport;
      if (ast.meta.features & FEATURE_CUSTOM_ELEMENT && componentImport.specifiers.length === 0) {
        const moduleImportName = (0, import_camel_case.camelCase)(importUrl + "Module");
        state.importStatements.add(`import * as ${moduleImportName} from '${importUrl}';
`);
        state.customElementCandidates.set(moduleImportName, getComponentUrl(astroConfig, importUrl, pathToFileURL(filename)));
      } else {
        state.importStatements.add(module.content.slice(start || void 0, end || void 0));
      }
    }
    for (const componentImport of componentExports) {
      const {start, end} = componentImport;
      state.exportStatements.add(module.content.slice(start || void 0, end || void 0));
    }
    if (componentProps.length > 0) {
      const shortname = path3.posix.relative(compileOptions.astroConfig.projectRoot.pathname, state.filename);
      const props = componentProps.map((prop) => {
        var _a2;
        return (_a2 = prop.id) == null ? void 0 : _a2.name;
      }).filter((v) => v);
      warn(compileOptions.logging, shortname, yellow2(`
Defining props with "export" has been removed! Please see https://github.com/snowpackjs/astro/blob/main/packages/astro/CHANGELOG.md#0150
Please update your code to use:

const { ${props.join(", ")} } = Astro.props;
`));
    }
    if (createCollection) {
      const ast2 = babelParser.parse(createCollection, {
        sourceType: "module"
      });
      traverse(ast2, {
        enter({node}) {
          switch (node.type) {
            case "VariableDeclaration": {
              for (const declaration of node.declarations) {
                if (!isFetchContent(declaration))
                  continue;
                let {id, init} = declaration;
                if (!id || !init || id.type !== "Identifier")
                  continue;
                if (init.type === "AwaitExpression") {
                  init = init.argument;
                  const shortname = path3.relative(compileOptions.astroConfig.projectRoot.pathname, state.filename);
                  warn(compileOptions.logging, shortname, yellow2("awaiting Astro.fetchContent() not necessary"));
                }
                if (init.type !== "CallExpression")
                  continue;
                const namespace = id.name;
                if (init.arguments[0].type !== "StringLiteral") {
                  throw new Error(`[Astro.fetchContent] Only string literals allowed, ex: \`Astro.fetchContent('./post/*.md')\`
  ${state.filename}`);
                }
                const spec = init.arguments[0].value;
                if (typeof spec !== "string")
                  break;
                const globResult = fetchContent(spec, {namespace, filename: state.filename});
                let imports = "";
                for (const importStatement of globResult.imports) {
                  imports += importStatement + "\n";
                }
                createCollection = imports + createCollection.substring(0, declaration.start || 0) + globResult.code + createCollection.substring(declaration.end || 0);
              }
              break;
            }
          }
        }
      });
    }
    for (const [namespace, {spec}] of contentImports.entries()) {
      const globResult = fetchContent(spec, {namespace, filename: state.filename});
      for (const importStatement of globResult.imports) {
        state.importStatements.add(importStatement);
      }
      contentCode += globResult.code;
    }
    script = propsStatement + contentCode + babelGenerator(program).code;
    const location = {start: module.start, end: module.end};
    let transpiledScript = transpileExpressionSafe(script, {state, compileOptions, location});
    if (transpiledScript === null)
      throw new Error(`Unable to compile script`);
    script = transpiledScript;
  }
  return {
    script,
    createCollection: createCollection || void 0
  };
}
function compileCss(style, state) {
  walk2(style, {
    enter(node) {
      if (node.type === "Style") {
        state.css.push(node.content.styles);
        this.skip();
      }
    },
    leave(node) {
      if (node.type === "Style") {
        this.remove();
      }
    }
  });
}
function dedent(str) {
  var _a;
  let arr = str.match(/^[ \t]*(?=\S)/gm);
  let first = !!arr && ((_a = arr.find((x) => x.length > 0)) == null ? void 0 : _a.length);
  return !arr || !first ? str : str.replace(new RegExp(`^[ \\t]{0,${first}}`, "gm"), "");
}
var FALSY_EXPRESSIONS = new Set(["false", "null", "undefined", "void 0"]);
async function compileHtml(enterNode, state, compileOptions) {
  return new Promise((resolve) => {
    const {components, css, importStatements, exportStatements, filename, fileID} = state;
    const {astroConfig} = compileOptions;
    let paren = -1;
    let buffers = {
      out: "",
      markdown: ""
    };
    let curr = "out";
    async function pushMarkdownToBuffer() {
      const md = buffers.markdown;
      const {markdownOptions = {}} = astroConfig;
      if (!md.trim()) {
        buffers.out += "," + md;
        buffers.markdown = "";
        curr = "out";
        return;
      }
      const {$scope: scopedClassName} = state.markers.insideMarkdown;
      let {content: rendered} = await renderMarkdown(dedent(md), __spreadProps(__spreadValues({}, markdownOptions), {
        $: {scopedClassName: scopedClassName && scopedClassName.slice(1, -1)}
      }));
      const ast = parse(rendered);
      await transform(ast, {
        compileOptions,
        filename,
        fileID
      });
      const result = await compileHtml(ast.html, __spreadProps(__spreadValues({}, state), {markers: {insideMarkdown: false}}), compileOptions);
      buffers.out += "," + result;
      buffers.markdown = "";
      curr = "out";
    }
    asyncWalk(enterNode, {
      async enter(node, parent) {
        switch (node.type) {
          case "Expression": {
            let code = await compileExpression(node, state, compileOptions);
            if (FALSY_EXPRESSIONS.has(code)) {
              this.skip();
              break;
            }
            if (code !== "") {
              if (state.markers.insideMarkdown) {
                buffers[curr] += `{${code}}`;
              } else {
                buffers[curr] += `,(${code})`;
              }
            }
            this.skip();
            break;
          }
          case "MustacheTag":
            if (state.markers.insideMarkdown) {
              if (curr === "out")
                curr = "markdown";
            }
            return;
          case "Comment":
            return;
          case "Fragment": {
            buffers[curr] += `h(Fragment, null,`;
            break;
          }
          case "SlotTemplate": {
            buffers[curr] += `h(Fragment, null, children`;
            paren++;
            return;
          }
          case "Slot":
          case "Head":
          case "InlineComponent": {
            switch (node.name) {
              case "Prism": {
                if (!importStatements.has(PRISM_IMPORT)) {
                  importStatements.add(PRISM_IMPORT);
                }
                if (!components.has("Prism")) {
                  components.set("Prism", {
                    importSpecifier: {
                      type: "ImportDefaultSpecifier",
                      local: {type: "Identifier", name: "Prism"}
                    },
                    url: "astro/components/Prism.astro"
                  });
                }
                break;
              }
            }
          }
          case "Title":
          case "Element": {
            const name = node.name;
            if (!name) {
              throw new Error("AHHHH");
            }
            try {
              const attributes = await getAttributes(node.attributes, state, compileOptions);
              const hydrationAttributes = findHydrationAttributes(attributes);
              buffers.out += buffers.out === "" ? "" : ",";
              if (node.type === "Slot") {
                buffers[curr] += `(children`;
                paren++;
                return;
              }
              if (!isComponentTag(name)) {
                if (curr === "markdown") {
                  await pushMarkdownToBuffer();
                }
                buffers[curr] += `h("${name}", ${attributes ? generateAttributes(attributes) : "null"}`;
                paren++;
                return;
              }
              const [componentName, componentKind] = name.split(":");
              let componentInfo = components.get(componentName);
              if (/\./.test(componentName)) {
                const [componentNamespace] = componentName.split(".");
                componentInfo = components.get(componentNamespace);
              }
              if (state.declarations.has(componentName) && !componentInfo && !isCustomElementTag(componentName)) {
                if (hydrationAttributes.method) {
                  throw new Error(`Unable to hydrate "${componentName}" because it is statically defined in the frontmatter script. Hydration directives may only be used on imported components.`);
                }
                if (curr === "markdown") {
                  await pushMarkdownToBuffer();
                }
                paren++;
                buffers[curr] += `h(${componentName}, ${attributes ? generateAttributes(attributes) : "null"}`;
                return;
              } else if (!state.declarations.has(componentName) && !componentInfo && !isCustomElementTag(componentName)) {
                throw new Error(`Unable to render "${componentName}" because it is undefined
  ${state.filename}`);
              }
              if (componentName === "Markdown") {
                const {$scope} = attributes != null ? attributes : {};
                state.markers.insideMarkdown = typeof state.markers.insideMarkdown === "object" ? {$scope, count: state.markers.insideMarkdown.count + 1} : {$scope, count: 1};
                const keys = Object.keys(attributes).filter((attr) => attr !== "$scope");
                if (keys.length > 0) {
                  if (curr === "markdown") {
                    await pushMarkdownToBuffer();
                  }
                  buffers[curr] += `,${componentName}.__render(${attributes ? generateAttributes(attributes) : "null"}),`;
                }
                curr = "markdown";
                return;
              }
              const {wrapper, wrapperImports} = getComponentWrapper(name, hydrationAttributes, componentInfo != null ? componentInfo : {}, {astroConfig, filename, compileOptions});
              if (wrapperImports) {
                for (let wrapperImport of wrapperImports) {
                  importStatements.add(wrapperImport);
                }
              }
              if (curr === "markdown") {
                await pushMarkdownToBuffer();
              }
              paren++;
              buffers[curr] += `h(${wrapper}, ${attributes ? generateAttributes(attributes) : "null"}`;
            } catch (err) {
              paren--;
              const rel = filename.replace(astroConfig.projectRoot.pathname, "");
              error(compileOptions.logging, rel, err.toString());
            }
            return;
          }
          case "Attribute":
          case "Spread": {
            this.skip();
            return;
          }
          case "Style": {
            css.push(node.content.styles);
            this.skip();
            return;
          }
          case "CodeSpan":
          case "CodeFence": {
            if (state.markers.insideMarkdown) {
              if (curr === "out")
                curr = "markdown";
              buffers[curr] += node.raw;
              return;
            }
            buffers[curr] += "," + JSON.stringify(node.data);
            return;
          }
          case "Text": {
            let text = getTextFromAttribute(node);
            if (state.markers.insideMarkdown) {
              if (curr === "out")
                curr = "markdown";
              buffers[curr] += text;
              return;
            }
            if (parent.name !== "Markdown" && !text.trim()) {
              return;
            }
            if (parent.name === "code") {
              text = node.raw.replace(/&#x26;#123;/g, "{");
            }
            buffers[curr] += "," + JSON.stringify(text);
            return;
          }
          default:
            throw new Error("Unexpected (enter) node type: " + node.type);
        }
      },
      async leave(node, parent, prop, index) {
        switch (node.type) {
          case "Fragment": {
            buffers[curr] += `)`;
            break;
          }
          case "Text":
          case "Attribute":
          case "Spread":
          case "Comment":
          case "Expression":
          case "MustacheTag":
          case "CodeSpan":
          case "CodeFence":
            return;
          case "SlotTemplate":
          case "Slot":
          case "Head":
          case "Body":
          case "Title":
          case "Element": {
            if (curr === "markdown") {
              await pushMarkdownToBuffer();
            }
            if (paren !== -1) {
              buffers.out += ")";
              paren--;
            }
            return;
          }
          case "InlineComponent": {
            if (node.name === "Markdown") {
              state.markers.insideMarkdown.count--;
              if (state.markers.insideMarkdown.count <= 0) {
                state.markers.insideMarkdown = false;
              }
              const hasAttrs = node.attributes.filter(({name}) => name !== "$scope").length > 0;
              if (hasAttrs) {
                return;
              }
            }
            if (curr === "markdown" && buffers.markdown !== "") {
              await pushMarkdownToBuffer();
              if (!state.markers.insideMarkdown) {
                return;
              }
            }
            if (paren !== -1) {
              buffers.out += ")";
              paren--;
            }
            return;
          }
          case "Style": {
            this.remove();
            return;
          }
          default:
            throw new Error("Unexpected (leave) node type: " + node.type);
        }
      }
    }).then(() => {
      const content = buffers.out.replace(/^\,/, "").replace(/\,\)/g, ")").replace(/\,+/g, ",").replace(/\)h/g, "),h");
      buffers.out = "";
      buffers.markdown = "";
      return resolve(content);
    });
  });
}
async function codegen(ast, {compileOptions, filename, fileID}) {
  await eslexer.init;
  const state = {
    filename,
    fileID,
    components: new Map(),
    css: [],
    markers: {
      insideMarkdown: false
    },
    declarations: new Set(),
    importStatements: new Set(),
    exportStatements: new Set(),
    customElementCandidates: new Map()
  };
  const {script, createCollection} = compileModule(ast, ast.module, state, compileOptions);
  compileCss(ast.css, state);
  const html = await compileHtml(ast.html, state, compileOptions);
  return {
    script,
    imports: Array.from(state.importStatements),
    exports: Array.from(state.exportStatements),
    html,
    css: state.css.length ? state.css.join("\n\n") : void 0,
    createCollection,
    hasCustomElements: Boolean(ast.meta.features & FEATURE_CUSTOM_ELEMENT),
    customElementCandidates: state.customElementCandidates
  };
}

// src/compiler/index.ts
async function convertAstroToJsx(template, opts) {
  const {filename} = opts;
  const ast = parse2(template, {
    filename
  });
  await transform(ast, opts);
  return await codegen(ast, opts);
}
async function convertMdToAstroSource(contents, {filename}, opts) {
  let _a = await renderMarkdownWithFrontmatter(contents, opts), {
    content,
    frontmatter: _b
  } = _a, _c = _b, {layout} = _c, frontmatter = __objRest(_c, ["layout"]), data = __objRest(_a, [
    "content",
    "frontmatter"
  ]);
  if (frontmatter["astro"] !== void 0) {
    throw new Error(`"astro" is a reserved word but was used as a frontmatter value!
	at ${filename}`);
  }
  const contentData = __spreadValues(__spreadValues({}, frontmatter), data);
  const stringifiedSetupContext = JSON.stringify(contentData).replace(/\<\/script\>/g, `</scrip" + "t>`);
  return `---
${layout ? `import {__renderPage as __layout} from '${layout}';` : "const __layout = undefined;"}
export const __content = ${stringifiedSetupContext};
---
${content}`;
}
async function convertMdToJsx(contents, {compileOptions, filename, fileID}) {
  const raw = await convertMdToAstroSource(contents, {filename}, compileOptions.astroConfig.markdownOptions);
  const convertOptions = {compileOptions, filename, fileID};
  return await convertAstroToJsx(raw, convertOptions);
}
async function transformFromSource(contents, {compileOptions, filename, projectRoot}) {
  const fileID = path4.relative(projectRoot, filename);
  switch (true) {
    case filename.slice(-6) === ".astro":
      return await convertAstroToJsx(contents, {compileOptions, filename, fileID});
    case filename.slice(-3) === ".md":
      return await convertMdToJsx(contents, {compileOptions, filename, fileID});
    default:
      throw new Error("Not Supported!");
  }
}
async function compileComponent(source, {compileOptions, filename, projectRoot}) {
  const result = await transformFromSource(source, {compileOptions, filename, projectRoot});
  const site = compileOptions.astroConfig.buildOptions.site || `http://localhost:${compileOptions.astroConfig.devOptions.port}`;
  let moduleJavaScript = `
import fetch from 'node-fetch';

// <script astro></script>
${result.imports.join("\n")}
${result.hasCustomElements ? `
const __astro_element_registry = new AstroElementRegistry({
  candidates: new Map([${Array.from(result.customElementCandidates).map(([identifier, url]) => `[${identifier}, '${url}']`).join(", ")}])
});
`.trim() : ""}

// \`__render()\`: Render the contents of the Astro module.
import { h, Fragment } from 'astro/dist/internal/h.js';
const __astroInternal = Symbol('astro.internal');
async function __render(props, ...children) {
  const Astro = {
    props,
    site: new URL('/', ${JSON.stringify(site)}),
    css: (props[__astroInternal] && props[__astroInternal].css) || [],
    request: (props[__astroInternal] && props[__astroInternal].request) || {},
    isPage: (props[__astroInternal] && props[__astroInternal].isPage) || false,
  };

  ${result.script}
  return h(Fragment, null, ${result.html});
}
export default { isAstroComponent: true, __render };

${result.createCollection || ""}

// \`__renderPage()\`: Render the contents of the Astro module as a page. This is a special flow,
// triggered by loading a component directly by URL.
export async function __renderPage({request, children, props, css}) {
  const currentChild = {
    isAstroComponent: true,
    layout: typeof __layout === 'undefined' ? undefined : __layout,
    content: typeof __content === 'undefined' ? undefined : __content,
    __render,
  };

  Object.defineProperty(props, __astroInternal, {
    value: {
      request,
      css,
      isPage: true
    },
    writable: false,
    enumerable: false
  })

  const childBodyResult = await currentChild.__render(props, children);

  // find layout, if one was given.
  if (currentChild.layout) {
    return currentChild.layout({
      request,
      props: {content: currentChild.content},
      children: [childBodyResult],
    });
  }

  return childBodyResult;
};

${result.exports.join("\n")}

`;
  return {
    result,
    contents: moduleJavaScript,
    css: result.css
  };
}
export {
  compileComponent,
  convertAstroToJsx,
  convertMdToAstroSource,
  scopeRule
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb3dlci1jYXNlL3NyYy9pbmRleC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbm8tY2FzZS9zcmMvaW5kZXgudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bhc2NhbC1jYXNlL3NyYy9pbmRleC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FtZWwtY2FzZS9zcmMvaW5kZXgudHMiLCAiLi4vLi4vc3JjL2NvbXBpbGVyL2luZGV4LnRzIiwgIi4uLy4uL3NyYy9jb21waWxlci90cmFuc2Zvcm0vaW5kZXgudHMiLCAiLi4vLi4vc3JjL2NvbXBpbGVyL3RyYW5zZm9ybS9zdHlsZXMudHMiLCAiLi4vLi4vc3JjL2xvZ2dlci50cyIsICIuLi8uLi9zcmMvY29tcGlsZXIvdHJhbnNmb3JtL3Bvc3Rjc3Mtc2NvcGVkLXN0eWxlcy9pbmRleC50cyIsICIuLi8uLi9zcmMvY29tcGlsZXIvdHJhbnNmb3JtL2RvY3R5cGUudHMiLCAiLi4vLi4vc3JjL2FzdC50cyIsICIuLi8uLi9zcmMvY29tcGlsZXIvdHJhbnNmb3JtL21vZHVsZS1zY3JpcHRzLnRzIiwgIi4uLy4uL3NyYy9jb21waWxlci90cmFuc2Zvcm0vcHJpc20udHMiLCAiLi4vLi4vc3JjL2NvbXBpbGVyL3RyYW5zZm9ybS91dGlsL2VuZC1vZi1oZWFkLnRzIiwgIi4uLy4uL3NyYy9jb21waWxlci90cmFuc2Zvcm0vaGVhZC50cyIsICIuLi8uLi9zcmMvY29tcGlsZXIvY29kZWdlbi9pbmRleC50cyIsICIuLi8uLi9zcmMvY29tcGlsZXIvY29kZWdlbi9jb250ZW50LnRzIiwgIi4uLy4uL3NyYy9jb21waWxlci9jb2RlZ2VuL3V0aWxzLnRzIiwgIi4uLy4uL3NyYy9jb21waWxlci91dGlscy50cyIsICIuLi8uLi9zcmMvbm9kZV9idWlsdGlu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
